# JS 

## Hoisting
```
var a = 5;  
function foo() {  
  console.log(a); // undefined  
  var a = 10;  
}  
foo();

var foo = 1; 
function bar() { 
    if (!foo) { 
        var foo = 10; 
    } 
    console.log(foo); // 10
} 
bar();

var a = 1; 
function b() { 
    a = 10; 
    return; 
    function a() {} 
} 
b();
console.log(a); // 1
```
## Typing
```
var a = '5' + 1; // '51'
var a = '5' - 1; // 4
```
## [native code]
```
function baz() {
  var baz = b = 5;
}
baz();
console.log(baz); // ƒ baz() { var baz = b = 5; }
console.log(b); // 5
```
## 
```
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // 10 10
  },0);
}

for (var i = 0; i < 10; i++) {
  (function(i){
	  setTimeout(function() {
    	console.log(i); // from 0 to 9
  	},0);
  }(i));
}
for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // from 0 to 9
  },0);
}
```
## 
```
'use strict';
var f = function () {
  console.log('1'); // (2) '1'
}
(function() {
  console.log('2'); // (1) '2'
}())
```
##
```
var sum = function (a) {
  return function(b) {
    return a + b;
  }
}
sum(5)(6); // 11
```
## Descriptors
```
некоторые флаги:

    * writable — значение свойства может быть изменено, используется только для дескрипторов данных.
    * configurable — тип свойства может быть изменён или свойство может быть удалено.
    * enumerable — свойство используется в общем перечислении.
      Дескрипторы данных таковы, что определяют конкретное значение, которое соответствует дополнительному
      value - параметру, описывающему конкретные данные, привязанные к свойству:
    * value — значение свойства
```
##
```
Напишите функцию принимающую строку с именем файла и возвращающую расширение (фрагмент после последней точки)
'some.class.js'.split('.').pop(); // "js"
```
## Привязка контекста (Bind, Call, Apply)
```
Методы call/apply вызывают функцию с заданным контекстом и аргументами.

А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}

var user = {
  firstName: "Вася",
  sayHi: function() {
    console.log( this.firstName );
  }
};

setTimeout(bind(user.sayHi, user), 1000);
```
## структуры данных
```
/*** ===================================================================== ***\
 *           a           b                                 d                 *
 *           a         b    O(N^2)                      d                    *
 *     O(N!) a        b                O(N log N)    d                    c  *
 *           a      b                            d                 c         *
 *          a      b                          d             c        O(N)    *
 *          a    b                         d         c                       *
 *          a  b                       d      c                              *
 *         a  b                     d  c                                     *
 *         ab                   c                          O(1)              *
 *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *
 *      ba        c      d                                                   *
 *    ba   c        d                       f    f    f    f    f    f    f  *
 ** cadf    f d    f    f    f    f    f       O(log N)                     **
\*** ===================================================================== ***/

«О» большое — обозначение способа приблизительной оценки производительности алгоритмов для относительного сравнения.

                          Доступ      Поиск       Вставка      Удаление
------------------------------------------------------------------------
                Массив    O(1)        O(N)        O(N)         O(N)
        Связный список    O(N)        O(N)        O(1)         O(1)
Двоичное дерево поиска    O(log N)    O(log N)    O(log N)     O(log N)

                          Доступ       Поиск      Вставка      Удаление
------------------------------------------------------------------------
                Массив    ОХРЕНЕННО    НОРМАС     НОРМАС       НОРМАС
        Связный список    НОРМАС       НОРМАС     ОХРЕНЕННО    ОХРЕНЕННО
Двоичное дерево поиска    КРУТО        КРУТО      КРУТО        КРУТО
```

**Список** — представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз.
```
Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними.
Но для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти.
```
Сложность операции доступа в список — O(1)  
Удаление элемента из конца списка — O(1)  
Добавление элемента в начало списка — линейно O(N)  
Удаление элемента из начала списка — линейно O(N)  

**Хеш-таблица** — неупорядоченная структура данных. Вместо индексов мы работаем с «ключами» и «значениями», вычисляя адрес памяти по ключу.

Сложность чтения значения из хеш-таблицы — константа O(1)  
Сложность установки значения в хеш-таблицу — константа O(1)  
Сложность удаления значения из хеш-таблицы — константа O(1)  

**Стеки** похожи на списки. Они также упорядочены, но ограничены в действиях: можно лишь добавлять и убирать значения из конца списка. 
















