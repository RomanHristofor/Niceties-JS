# JS
## Какие типы данных существуют в JavaScript?
Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
Строка «string»
Булевый (логический) тип «boolean»
Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
Объекты «object» - Первые 5 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}

## В чем разница между let, const и var?

## var
поднимается в начало области видимости функции при компиляции
объявляет переменную, которая может быть перезаписана
объявляет переменную, которая может быть переопределена

## let
поднимается в начало области видимости блока при компиляции
объявляет переменную, которая может быть перезаписана
объявляет переменную, которая не может быть переопределена

## const
поднимается в начало области видимости блока при компиляции
объявляет переменную, которая не может быть перезаписана или переопределена

## Объясните разницу между синхронными и асинхронными функциями
JavaScript - это однопоточный язык, то-есть функции выполняются в синхронном порядке. Приложение блокируется на время выполнения каждой конкретной функции. Так происходит по той причине, что JavaScript имеет только один стек вызовов.

С другой стороны, есть асинхронный способ выполнения функций, когда мы не блокируем весь интерфейс благодаря тому, что не дожидаемся выполнения функции, а подписываемся на событие с передачей обратного вызова. Ну, или мы можем иметь дело с обещанием или с прочими внешними API вроде setTimeout.

В таком случае браузер помещает обработчик события в очередь задач, а когда наступает время его вызвать, он перемещает его в стек вызовов.


## Что такое hoisting (поднятие) в JavaScript?
Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.

Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.

По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression

## Что такое замыкание?
Каждую ф-цию в JS можно назвать замыканием. Когда интерпретатор выполняет какую-либо ф-цию он создает объект который будет содержать все локальные переменные для данного вызова ф-ции и все ф-ции внутри этой ф-ции сохраняют ссылку на этот объект(LexicalEnvironment) c переменными. И этот объект существуюет только в том случае если есть функции которые на него ссылаются.

## Прототипное наследование?
Объекты в JS динамические. Каждый объект содержит ссылку на свой объект-прототип. При попытке получить доступ к какому-либо свойству объекта свойство ищется по цепочке прототипов, пока не находится или не достигается конца цепочки, тогда возвращается undefined.

## Прототип объекта
Называется другой объект из которого текущий берет методы и свойства. 
[[Prototype]] - это скрытое свойство указывает на прототип текущего объекта.
Prototype - это св-во ф-ции которое используется для передачи значения ссылке [[Prototype]] создоваемого объекта.

В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер).
Объект, на который ссылается [[Prototype]], называется «прототипом».

## Как работает ключевое слово this?
В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме. В пределах функции значение this зависит от того, каким образом вызвана функция:

Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.


## Привязка контекста (Bind, Call, Apply)
```javascript
Методы call/apply вызывают функцию с заданным контекстом и аргументами.

А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}

var user = {
  firstName: "Vasili",
  sayHi: function() {
    console.log( this.firstName );
  }
};

setTimeout(bind(user.sayHi, user), 100);
```

## Какие существуют методы оптимизации производительности в JS?
 Вот некоторые методы оптимизации:

1. Использование let и const вместо var:
let и const имеют блочную область видимости, что позволяет более точно контролировать область видимости переменных
 и избегать нежелательных эффектов.

2. Избегание глобальных переменных:
Глобальные переменные могут вызывать конфликты и усложнять отладку. Старайтесь минимизировать использование
 глобального пространства имен.

3. Оптимизация циклов:
Используйте схемы оптимизации циклов, такие как предварительное вычисление длины
```for (let i = 0, len = array.length; i < len; i++)```
или использование методов массивов: forEach, map, filter, вместо явных циклов.

5. Кэширование переменных:
Если вы часто обращаетесь к одному и тому же объекту, то имеет смысл закешировать его в переменной,
 чтобы избежать повторных обращений.

6. Использование строгого равенства (===) вместо нестрогого (==):
Строгое равенство не приводит типы, что уменьшает вероятность неявных преобразований и может ускорить выполнение кода.

7. Использование массивов вместо объектов для хранения упорядоченных данных:
Для операций, требующих поиска по индексу, массивы часто более эффективны.

8. Оптимизация работы с DOM:
Минимизируйте количество обращений к DOM. Используйте методы типа `querySelector` для эффективного поиска элементов.

9. Делегирование событий:
Используйте `делегирование событий` для оптимизации работы с большим количеством элементов.
 Вместо присоединения обработчиков к каждому элементу, присоединяйте их к их общему родителю.

10. Оптимизация работы с циклами и рекурсией:
Важно оптимизировать алгоритмы и убедиться, что они работают с максимальной эффективностью.

11. Минимизация запросов к серверу и оптимизация загрузки ресурсов:
Сокращение числа запросов к серверу, минификация и сжатие файлов, асинхронная загрузка ресурсов
 и другие методы могут существенно повысить производительность веб-приложения.

12. Использование `Web Workers` и `Service Workers`:
Позволяют выполнять вычисления в отдельных потоках и кэшировать ресурсы для улучшения производительности.

13. Использование инструментов для анализа и профилирования кода:
Инструменты, такие как `Chrome DevTools`, позволяют выявить узкие места в коде и оптимизировать их.

Важно помнить, что оптимизация не всегда означает уменьшение количества кода,
а скорее - повышение эффективности его работы. 
Выбор методов оптимизации зависит от конкретной задачи и контекста разработки.


## CORS
Cross-Origin Resource Sharing — это механизм в веб-браузерах, который позволяет ограничивать
 или разрешать запросы к ресурсам с других источников (origin) в веб-приложениях.
Origin включает в себя схему (например, http или https), домен и порт.

Когда веб-страница загружается из одного `origin` и пытается выполнить запрос к ресурсу (например, JavaScript-файлу или API) на другом
 `origin`, браузер использует механизмы безопасности, в том числе `CORS`, чтобы решить, разрешено ли выполнение этого запроса.

Вот основные аспекты `CORS`:
`Простые запросы (Simple Requests)`: Обычные HTTP-запросы методом GET, HEAD и POST с определенными заголовками считаются "простыми" и
 по умолчанию разрешаются. Простые запросы могут быть выполнены без предварительной проверки сервера.
`Непростые запросы (Non-Simple Requests)`: Если запрос отличается от простого (например, использует метод PUT или DELETE,
 или имеет определенные кастомные заголовки), браузер сначала отправит предварительный запрос с методом `OPTIONS (preflight request)`
  для уточнения, разрешено ли такое действие. Сервер должен ответить с соответствующими заголовками, разрешая или запрещая запрос.

`Заголовки CORS`: Сервер может отправить специальные заголовки в ответе для указания правил `CORS`. Например, заголовок `Access-Control-Allow-Origin`
 указывает, каким источникам разрешено делать запросы.
`Методы запроса`: Методы запросов, которые разрешены для данного ресурса, указываются с помощью заголовка `Access-Control-Allow-Methods`.
`Заголовки запроса`: Заголовки, которые разрешено передавать в запросе, указываются с помощью заголовка `Access-Control-Allow-Headers`.

`Управление куки`: По умолчанию, при кросс-доменных запросах не отправляются куки. Если сервер хочет принимать куки, он должен указать
 заголовок `Access-Control-Allow-Credentials` и клиент должен установить соответствующую опцию `withCredentials` в запросе.

`Проверка запросов (Preflight)`: В некоторых случаях браузер может отправить предварительный запрос `preflight с методом OPTIONS,
 чтобы уточнить, разрешено ли выполнение основного запроса. Это происходит, когда запрос считается "непростым".

`Wildcard (Знак мультиподстановки)`: Заголовок `Access-Control-Allow-Origin` может принимать значение *, что разрешает доступ 
всем источникам. Однако, это считается менее безопасным и используется в особых случаях.

`CORS` позволяет веб-страницам взаимодействовать с ресурсами с других источников, но в то же время предотвращает выполнение запросов
 с злоумышленных сайтов. Он важен для обеспечения безопасности веб-приложений.

## Куки
`cookies` в веб-разработке - это небольшие фрагменты данных, которые веб-сайты сохраняют на устройстве пользователя.
Они играют ключевую роль в современном интернете, выполняя различные функции. 
 Вот несколько основных аспектов и использований куки:
`Хранение Сессий`: Куки часто используются для отслеживания сессий пользователей. Когда пользователь входит на сайт,
   сервер может создать уникальный идентификатор сессии и сохранить его в куки. Это позволяет серверу идентифицировать
    пользователя при каждом последующем запросе, сохраняя его состояние входа в систему.
`Персонализация`: Сайты используют куки для хранения персональных настроек пользователя, таких как выбранный язык,
   тема оформления или предпочтения в содержании. Это обеспечивает более персонализированный пользовательский опыт.
`Отслеживание и Аналитика`: Куки помогают в сборе данных о поведении пользователя на сайте. Эта информация может использоваться
   для аналитики, помогая понять, как пользователи взаимодействуют с сайтом, что в свою очередь может способствовать улучшению
    веб-сервисов.
`Реклама`: Куки используются для отслеживания пользовательской активности в интернете, что позволяет рекламодателям показывать
   более целевую и релевантную рекламу. Это может включать рекламу, основанную на недавних поисках или посещенных веб-страницах.
  `Безопасность`: Куки могут использоваться для повышения безопасности сайта, например, для предотвращения подделки 
  межсайтовых запросов (CSRF). Они могут содержать токены безопасности, которые проверяются сервером при каждом запросе.

**Типы Куки**:
`Сессионные куки`: Эти куки хранятся только во время сессии браузера и удаляются автоматически, когда браузер закрывается. 
  Они обычно используются для отслеживания сессий пользователя.
`Постоянные куки`: Эти куки сохраняются на устройстве пользователя в течение определенного времени, указанного в куки, 
  или до тех пор, пока они не будут удалены пользователем. Они используются для сохранения предпочтений пользователя и отслеживания
   поведения на долгосрочной основе.
`Управление и Конфиденциальность`: Пользователи и браузеры имеют возможность управлять куки, включая возможность блокировки
   или удаления их. Это важный аспект конфиденциальности, так как куки могут содержать чувствительные данные.

`cookies` могут иметь различные `атрибуты`, влияющие на их поведение и доступность. Один из таких атрибутов - `HttpOnly`,
 который иногда называют "readonly" кукой. Он имеет ключевое значение для безопасности веб-приложений.

`HttpOnly (Readonly) Cookie`:
`Ограничение Доступа`: Когда кука помечена как `HttpOnly`, это означает, что она недоступна для клиентских скриптов,таких как JavaScript.
Такая кука может быть отправлена только на сервер с `HTTP-запросами`.
`Защита от XSS-атак`: Основная цель `HttpOnly` куки - защита от кросс-сайтовых скриптинговых атак (XSS). При таких атаках
  злоумышленники могут вставлять `вредоносный код в веб-страницы`, который исполняется в браузере жертвы. 
Если куки содержат `чувствительные данные, такие как сессионные токены`, и они не защищены атрибутом `HttpOnly`,
вредоносный скрипт может прочитать эти куки и отправить данные злоумышленнику.

В целом, куки являются важным инструментом для обеспечения бесперебойной и персонализированной работы в интернете,
 но также вызывают опасения по поводу конфиденциальности и безопасности данных.

## SQL-инъекции, XSS атаки
*`SQL-инъекци`я — это тип атаки, при которой злоумышленник вводит вредоносные SQL-запросы через веб-формы или URL-адреса,
 что может привести к несанкционированному доступу к базе данных.

Пример безопасного запроса:
`SELECT * FROM users WHERE username='john' AND password='12345';`

Пример уязвимого запроса, подверженного SQL-инъекции:
`SELECT * FROM users WHERE username='' OR 1=1; --' AND password='12345';`
В данном примере, если не проводить адекватную фильтрацию входных данных, злоумышленник может ввести `' OR 1=1; --`
 в поле "username", что приведет к тому, что условие 1=1 всегда будет верным, и запрос вернет все строки из таблицы.

Чтобы предотвратить SQL-инъекции, следует использовать параметризованные запросы
 или подготовленные запросы, а не встраивать пользовательский ввод непосредственно в SQL-запросы.

*`XSS-атаки` (Cross-Site Scripting):
XSS-атаки — это атаки, при которых злоумышленник внедряет вредоносный JS-код в веб-страницу,
 который выполняется в браузере жертвы. Атаки могут быть сохраненными (persistent) или рефлектированными (reflected).

Сохраненные (Persistent) XSS:
При сохраненных XSS-атаках, зловредный код сохраняется на сервере и выполняется при каждом запросе к соответствующей странице.

Пример уязвимого места:
`<input type="text" value="USER_INPUT">`
Если при вводе данных в поле USER_INPUT не проводится должная фильтрация, злоумышленник может ввести JS-код,
 который будет выполнен в браузере всех пользователей, открывших эту страницу.

*Рефлектированные (Reflected) XSS:
При рефлектированных XSS-атаках, зловредный код внедряется в URL или форму и выполняется при загрузке страницы.
 Эти атаки зависят от того, что жертва перейдет по определенной ссылке.
Пример уязвимого URL:
```https://example.com/search?query=USER_INPUT
// Предполагаем, что userInput содержит ввод пользователя
const userInput = "некоторый_пользовательский_ввод";
// encodedUserInput будет содержать правильно закодированное значение
const encodedUserInput = encodeURIComponent(userInput);
// USER_INPUT, которое можно безопасно добавить к URL.
const url = https://example.com/search?query=${encodedUserInput};
```

Если значение USER_INPUT не экранируется или фильтруется некорректно, зловредный код может
 быть выполнен в контексте страницы.

Для предотвращения XSS-атак следует проводить валидацию и фильтрацию данных, а также использовать
 безопасные методы для вставки данных в HTML, такие как эскейпинг специальных символов (<, >, &, и так далее).

*`Cross-Site Request Forgery (CSRF)` Атака, заставляющая веб-браузер жертвы выполнять нежелательные действия на веб-сайте, на котором она аутентифицирована.
Предположим, что на веб-сайте есть следующая форма для изменения email-адреса:
```<!-- Пример уязвимой формы на веб-сайте -->
<form action="http://example.com/update-email" method="POST">
  <input type="email" name="newEmail" />
  <input type="submit" value="Изменить Email" />
</form>
```

Как Происходит CSRF-Атака?
`1)Подготовка Атакующим Запроса:`
Злоумышленник создает вредоносную веб-страницу или email с HTML-кодом, который автоматически 
отправляет POST-запрос на `example.com/update-email`, когда жертва загружает страницу или открывает email.

```<!-- Вредоносная веб-страница или email -->
<html>
  <body>
    <form action="http://example.com/update-email" method="POST" id="fakeForm">
      <input type="hidden" name="newEmail" value="attacker@example.com" />
    </form>
    <script>document.getElementById("fakeForm").submit();</script>
  </body>
</html>
```

`2)Выполнение Запроса:`
Когда пользователь, который аутентифицирован на `example.com`, открывает эту вредоносную страницу или email,
форма автоматически отправляется. Поскольку запрос отправляется с аутентификационными данными пользователя
(например, сессионными cookies), сервер `example.com` обрабатывает его как законный и изменяет email-адрес пользователя на адрес злоумышленника.

`3)Защита от CSRF`
Для защиты от CSRF-атак обычно используются токены, которые сервер встраивает в формы и проверяет при получении запросов:
```<form action="http://example.com/update-email" method="POST">
  <!-- Сервер генерирует уникальный токен и встраивает его в форму -->
  <input type="hidden" name="csrfToken" value="сгенерированный_уникальный_токен" />
  <input type="email" name="newEmail" />
  <input type="submit" value="Изменить Email" />
</form>
```
Сервер затем проверяет этот токен при обработке запроса. Если токен отсутствует или неверен, запрос отклоняется. Это предотвращает
 CSRF-атаки, поскольку злоумышленник не может знать или подделать токен, который генерируется сервером и является уникальным для
  каждой сессии пользователя.
Кроме того, для защиты от CSRF можно использовать такие меры:
`*Проверка Заголовка Referer:` Сервер может проверять заголовок HTTP Referer, чтобы убедиться, что запрос отправлен с доверенного
 источника.
`*Использование Сookie с Флагом SameSite:` Установка флага SameSite для куки помогает предотвратить отправку куки с запросами,
 инициированными с других сайтов.
`*Реализация Подтверждения Действий:` Для критически важных операций требовать от пользователя подтверждения действия,
 например, введения пароля или дополнительного кода подтверждения.
Эти методы помогают минимизировать риск CSRF-атак, обеспечивая более высокий уровень безопасности веб-приложений.


## SOLID
## S Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.
## O Принцип открытости/закрытости (open-closed principle)
«программные сущности должны быть открыты для расширения, но закрыты для модификации».
## L Принцип подстановки Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы»
Производный класс должен быть взаимозаменяем с родительским классом.
## I Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных лучше, чем один интерфейс общего назначения»
## D Принцип инверсии зависимостей (dependency inversion principle)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное»



## operator spread
```javascript
[a, b, ...iterableObj] = [1, 2, 3, 4, 5]; // iterableObj -> [3, 4, 5]
```

## Hoisting
```javascript
var a = 5;  
function foo() {  
  console.log(a); // undefined  
  var a = 10;  
}  
foo();

say('user'); // undefined, user
var phrase = 'Hello';
function say(name) {
  console.log( `${phrase}, ${name}` );
}

var foo = 1; 
function bar() { 
    if (!foo) { 
        var foo = 10; 
    } 
    console.log(foo); // 10
} 
bar();

var a = 1; 
function b() { 
    a = 10; 
    return; 
    function a() {} 
} 
b();
console.log(a); // 1

(function() {
   var a = b = 5;
})();
console.log(b); // 5
```

## Closures
```javascript
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // 10 10
  },0);
}

for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // from 0 to 9
  },0);
}

for (var i = 0; i < 10; i++) {
  (function(i){
    setTimeout(function() {
      console.log(i); // from 0 to 9
    },0);
  }(i));
}


var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }  
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();

Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); //2

console.log(Counter2.value()); //0
```

## Currying
```javascript
var sum = function (a) {
  return function(b) {
    return a + b;
  }
}
sum(5)(6); // 11

// Or
const sum = a => b => a + b;
sum(5)(6); // 11

```

## Typing
```javascript
var a = '5' + 1; // "51"
var a = '5' - 1; // 4

6 / "3" // 2

"2" * "3" // 6

4 + 5 + "px" // "9px"

"$" + 4 + 5 // "$45"

"4" - 2 // 2

"4px" - 2 // NaN
 
7 / 0 // Infinity

typeof null // "object"

typeof {}[0] // "undefined"

typeof ("4px" - 2) // "number"

parseInt("09") // 9

5 && 2 // 2
2 && 5 // 5
1 && 0 // 0
0 && -1 // 0
0 && 1 // 0

5 || 0 // 5
0 || 5 // 5
0 || -1 // -1
-1 || 0 // -1
```

## [native code]
```javascript
function baz() {
  var baz = b = 5;
}
baz();
console.log(baz); // ƒ baz() { var baz = b = 5; }
console.log(b); // 5
```

## Strict mode
```javascript
'use strict';
var f = function () {
  console.log('1'); // (2) '1'
}

(function() {
  console.log('2'); // (1) '2'
}())


'use strict';
NaN = 5; // TypeError

'use strict';
myVar = 12; // ReferenceError

'use strict';
0644 === 420 // SyntaxError: Octal literals are not allowed in strict mode.

'use strict';
var x;
delete x; // SyntaxError

```

## Fibonacci
```javascript
function fib(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}
fib(8); // 21

function fib(n) {
  let a = 1, b =1;

  for (let i = 3; i <= n; i++) {
    let c = a+b;
    a = b;
    b = c;
  };
  return b;
}
fib(7); // 13
```

## Factorial
```javascript
function fac(n) {
  return n ? n * fac(n - 1) : 1;
}
fac(5); // 120

function fact(n) {
    let res = 1;
    for (let i = 2; i <= n; i++) {
        res *= i;
    }
    return res;
}
fact(5);// 120
```

##
```javascript
function sortBubble(arr) {
    const n = arr.length - 1;

    for (let i = n; i > 0; i--) {
        for (let j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    return arr;
}
sortBubble( [5, 20, 3, 11, 1, 17, 3, 12, 8, 10, 22]); // [1, 3, 3, 5, 8, 10, 11, 12, 17, 20, 22]

function quickSort(arr) {
    if (arr.length <= 1) return arr;

    const pivot = arr[0];
    const left = [];
    const right = [];

    for(let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
quickSort([64, 34, 25, 12, 22, 11, 90]); // [11, 12, 22, 25, 34, 64, 90]


function getMaxNumber(arr) {
    let max = arr[0];

    for(let i = 0, l = arr.length; i < l; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
};
getMaxNumber([2,4,55,67,9,0,6]); // 67


// Побитовый XOR двух одинаковых чисел дает 0, а XOR с 0 не меняет число.
// Таким образом, если мы применим XOR ко всем элементам массива, то дублирующиеся элементы
// "вычтутся" друг из друга, и останется только уникальный элемент.
function singleNumber(nums) {
    let result = 0;
    
    for (let num of nums) {
        result ^= num;
    }
    
    return result;
}
singleNumber([2,2,1]); // 1
singleNumber([4,1,2,1,2]); // 4
singleNumber([1]); // 1


let A, B;
A = B = 'test';
A.c = 1;
B.c = 2;
console.log(A.c); // undefined
console.log(B.c); // undefined


let f = function() { 
  console.log(this.x);
};
let obj = {x: 'test'};

f.prototype = obj;
new f(); // "test"
```

## Descriptors
```
некоторые флаги:

    * writable — значение свойства может быть изменено, используется только для дескрипторов данных.
    * configurable — тип свойства может быть изменён или свойство может быть удалено.
    * enumerable — свойство используется в общем перечислении.
      Дескрипторы данных таковы, что определяют конкретное значение, которое соответствует дополнительному
      value - параметру, описывающему конкретные данные, привязанные к свойству:
    * value — значение свойства
```

## Напишите функцию принимающую строку с именем файла и возвращающую его расширение
```javascript
'some.class.js'.split('.').pop(); // "js"
```

## Структуры данных
```
/*** ===================================================================== ***\
 *           a           b                                 d                 *
 *           a         b    O(N^2)                      d                    *
 *     O(N!) a        b                O(N log N)    d                    c  *
 *           a      b                            d                 c         *
 *          a      b                          d             c        O(N)    *
 *          a    b                         d         c                       *
 *          a  b                       d      c                              *
 *         a  b                     d  c                                     *
 *         ab                   c                          O(1)              *
 *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *
 *      ba        c      d                                                   *
 *    ba   c        d                       f    f    f    f    f    f    f  *
 ** cadf    f d    f    f    f    f    f       O(log N)                     **
\*** ===================================================================== ***/

«О» большое — обозначение способа приблизительной оценки производительности алгоритмов для относительного сравнения.

                          Доступ      Поиск       Вставка      Удаление
------------------------------------------------------------------------
                Массив    O(1)        O(N)        O(N)         O(N)
        Связный список    O(N)        O(N)        O(1)         O(1)
Двоичное дерево поиска    O(log N)    O(log N)    O(log N)     O(log N)

                          Доступ       Поиск      Вставка      Удаление
------------------------------------------------------------------------
                Массив    ОХРЕНЕННО    НОРМАС     НОРМАС       НОРМАС
        Связный список    НОРМАС       НОРМАС     ОХРЕНЕННО    ОХРЕНЕННО
Двоичное дерево поиска    КРУТО        КРУТО      КРУТО        КРУТО
```

**Список** — представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз.
```
Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними.
Но для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти.
```
Сложность операции доступа в список — O(1)  
Удаление элемента из конца списка — O(1)  
Добавление элемента в начало списка — линейно O(N)  
Удаление элемента из начала списка — линейно O(N)  

**Хеш-таблица** — неупорядоченная структура данных. Вместо индексов мы работаем с «ключами» и «значениями», вычисляя адрес памяти по ключу.

Сложность чтения значения из хеш-таблицы — константа O(1)  
Сложность установки значения в хеш-таблицу — константа O(1)  
Сложность удаления значения из хеш-таблицы — константа O(1)  

**Стеки** похожи на списки. Они также упорядочены, но ограничены в действиях: можно лишь добавлять и убирать значения из конца списка. 
















