# JS
## Какие типы данных существуют в JavaScript?
Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
Строка «string»
Булевый (логический) тип «boolean»
Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
Объекты «object» - Первые 5 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}

## В чем разница между let, const и var?

## var
поднимается в начало области видимости функции при компиляции
объявляет переменную, которая может быть перезаписана
объявляет переменную, которая может быть переопределена

## let
поднимается в начало области видимости блока при компиляции
объявляет переменную, которая может быть перезаписана
объявляет переменную, которая не может быть переопределена

## const
поднимается в начало области видимости блока при компиляции
объявляет переменную, которая не может быть перезаписана или переопределена

## Объясните разницу между синхронными и асинхронными функциями
JavaScript - это однопоточный язык, то-есть функции выполняются в синхронном порядке. Приложение блокируется на время выполнения каждой конкретной функции. Так происходит по той причине, что JavaScript имеет только один стек вызовов.

С другой стороны, есть асинхронный способ выполнения функций, когда мы не блокируем весь интерфейс благодаря тому, что не дожидаемся выполнения функции, а подписываемся на событие с передачей обратного вызова. Ну, или мы можем иметь дело с обещанием или с прочими внешними API вроде setTimeout.

В таком случае браузер помещает обработчик события в очередь задач, а когда наступает время его вызвать, он перемещает его в стек вызовов.


## Что такое hoisting (поднятие) в JavaScript?
Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.

Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.

По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression

## Что такое замыкание?
Каждую ф-цию в JS можно назвать замыканием. Когда интерпретатор выполняет какую-либо ф-цию он создает объект который будет содержать все локальные переменные для данного вызова ф-ции и все ф-ции внутри этой ф-ции сохраняют ссылку на этот объект(LexicalEnvironment) c переменными. И этот объект существуюет только в том случае если есть функции которые на него ссылаются.

## Прототипное наследование?
Объекты в JS динамические. Каждый объект содержит ссылку на свой объект-прототип. При попытке получить доступ к какому-либо свойству объекта свойство ищется по цепочке прототипов, пока не находится или не достигается конца цепочки, тогда возвращается undefined.

## Прототип объекта
Называется другой объект из которого текущий берет методы и свойства. 
[[Prototype]] - это скрытое свойство указывает на прототип текущего объекта.
Prototype - это св-во ф-ции которое используется для передачи значения ссылке [[Prototype]] создоваемого объекта.

В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер).
Объект, на который ссылается [[Prototype]], называется «прототипом».

## Как работает ключевое слово this?
В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме. В пределах функции значение this зависит от того, каким образом вызвана функция:

Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.


## Привязка контекста (Bind, Call, Apply)
```javascript
Методы call/apply вызывают функцию с заданным контекстом и аргументами.

А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}

var user = {
  firstName: "Vasili",
  sayHi: function() {
    console.log( this.firstName );
  }
};

setTimeout(bind(user.sayHi, user), 100);
```



## SOLID
## S Принцип единственной ответственности (single responsibility principle)
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.
## O Принцип открытости/закрытости (open-closed principle)
«программные сущности должны быть открыты для расширения, но закрыты для модификации».
## L Принцип подстановки Лисков (Liskov substitution principle)
«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы»
Производный класс должен быть взаимозаменяем с родительским классом.
## I Принцип разделения интерфейса (interface segregation principle)
«много интерфейсов, специально предназначенных лучше, чем один интерфейс общего назначения»
## D Принцип инверсии зависимостей (dependency inversion principle)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное»



## operator spread
```javascript
[a, b, ...iterableObj] = [1, 2, 3, 4, 5]; // iterableObj -> [3, 4, 5]
```

## Hoisting
```javascript
var a = 5;  
function foo() {  
  console.log(a); // undefined  
  var a = 10;  
}  
foo();

say('user'); // undefined, user
var phrase = 'Hello';
function say(name) {
  console.log( `${phrase}, ${name}` );
}

var foo = 1; 
function bar() { 
    if (!foo) { 
        var foo = 10; 
    } 
    console.log(foo); // 10
} 
bar();

var a = 1; 
function b() { 
    a = 10; 
    return; 
    function a() {} 
} 
b();
console.log(a); // 1

(function() {
   var a = b = 5;
})();
console.log(b); // 5
```

## Closures
```javascript
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // 10 10
  },0);
}

for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i); // from 0 to 9
  },0);
}

for (var i = 0; i < 10; i++) {
  (function(i){
    setTimeout(function() {
      console.log(i); // from 0 to 9
    },0);
  }(i));
}


var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }  
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();

Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); //2

console.log(Counter2.value()); //0
```

## Currying
```javascript
var sum = function (a) {
  return function(b) {
    return a + b;
  }
}
sum(5)(6); // 11

// Or
const sum = a => b => a + b;
sum(5)(6); // 11

```

## Typing
```javascript
var a = '5' + 1; // "51"
var a = '5' - 1; // 4

6 / "3" // 2

"2" * "3" // 6

4 + 5 + "px" // "9px"

"$" + 4 + 5 // "$45"

"4" - 2 // 2

"4px" - 2 // NaN
 
7 / 0 // Infinity

typeof null // "object"

typeof {}[0] // "undefined"

typeof ("4px" - 2) // "number"

parseInt("09") // 9

5 && 2 // 2
2 && 5 // 5
1 && 0 // 0
0 && -1 // 0
0 && 1 // 0

5 || 0 // 5
0 || 5 // 5
0 || -1 // -1
-1 || 0 // -1
```

## [native code]
```javascript
function baz() {
  var baz = b = 5;
}
baz();
console.log(baz); // ƒ baz() { var baz = b = 5; }
console.log(b); // 5
```

## Strict mode
```javascript
'use strict';
var f = function () {
  console.log('1'); // (2) '1'
}

(function() {
  console.log('2'); // (1) '2'
}())


'use strict';
NaN = 5; // TypeError

'use strict';
myVar = 12; // ReferenceError

'use strict';
0644 === 420 // SyntaxError: Octal literals are not allowed in strict mode.

'use strict';
var x;
delete x; // SyntaxError

```

## Fibonacci
```javascript
function fibonacci(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}
fibonacci(8); // 21

function fib(n) {
  let a = 1, b =1;

  for (let i = 3; i <= n; i++) {
    let c = a+b;
    a = b;
    b = c;
  };
  return b;
}
fib(7); // 13
```

## Factorial
```javascript
function fac(n) {
  return n ? n * fac(n - 1) : 1;
}
fac(5); // 120

function fact(n) {
    let res = 1;
    for (let i = 2; i <= n; i++) {
        res *= i;
    }
    return res;
}
fact(5);// 120
```

##
```javascript
function sortBubble(arr) {
    const n = arr.length - 1;

    for (let i = n; i > 0; i--) {
        for (let j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    return arr;
}
sortBubble( [5, 20, 3, 11, 1, 17, 3, 12, 8, 10, 22]); // [1, 3, 3, 5, 8, 10, 11, 12, 17, 20, 22]

function quickSort(arr) {
    if (arr.length <= 1) return arr;

    const pivot = arr[0];
    const left = [];
    const right = [];

    for(let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
quickSort([64, 34, 25, 12, 22, 11, 90]); // [11, 12, 22, 25, 34, 64, 90]


function getMaxNumber(arr) {
    let max = arr[0];

    for(let i = 0, l = arr.length; i < l; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
};
getMaxNumber([2,4,55,67,9,0,6]); // 67


// Побитовый XOR двух одинаковых чисел дает 0, а XOR с 0 не меняет число.
// Таким образом, если мы применим XOR ко всем элементам массива, то дублирующиеся элементы
// "вычтутся" друг из друга, и останется только уникальный элемент.
function singleNumber(nums) {
    let result = 0;
    
    for (let num of nums) {
        result ^= num;
    }
    
    return result;
}
singleNumber([2,2,1]); // 1
singleNumber([4,1,2,1,2]); // 4
singleNumber([1]); // 1


let A, B;
A = B = 'test';
A.c = 1;
B.c = 2;
console.log(A.c); // undefined
console.log(B.c); // undefined


let f = function() { 
  console.log(this.x);
};
let obj = {x: 'test'};

f.prototype = obj;
new f(); // "test"
```

## Descriptors
```
некоторые флаги:

    * writable — значение свойства может быть изменено, используется только для дескрипторов данных.
    * configurable — тип свойства может быть изменён или свойство может быть удалено.
    * enumerable — свойство используется в общем перечислении.
      Дескрипторы данных таковы, что определяют конкретное значение, которое соответствует дополнительному
      value - параметру, описывающему конкретные данные, привязанные к свойству:
    * value — значение свойства
```

## Напишите функцию принимающую строку с именем файла и возвращающую его расширение
```javascript
'some.class.js'.split('.').pop(); // "js"
```

## Структуры данных
```
/*** ===================================================================== ***\
 *           a           b                                 d                 *
 *           a         b    O(N^2)                      d                    *
 *     O(N!) a        b                O(N log N)    d                    c  *
 *           a      b                            d                 c         *
 *          a      b                          d             c        O(N)    *
 *          a    b                         d         c                       *
 *          a  b                       d      c                              *
 *         a  b                     d  c                                     *
 *         ab                   c                          O(1)              *
 *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *
 *      ba        c      d                                                   *
 *    ba   c        d                       f    f    f    f    f    f    f  *
 ** cadf    f d    f    f    f    f    f       O(log N)                     **
\*** ===================================================================== ***/

«О» большое — обозначение способа приблизительной оценки производительности алгоритмов для относительного сравнения.

                          Доступ      Поиск       Вставка      Удаление
------------------------------------------------------------------------
                Массив    O(1)        O(N)        O(N)         O(N)
        Связный список    O(N)        O(N)        O(1)         O(1)
Двоичное дерево поиска    O(log N)    O(log N)    O(log N)     O(log N)

                          Доступ       Поиск      Вставка      Удаление
------------------------------------------------------------------------
                Массив    ОХРЕНЕННО    НОРМАС     НОРМАС       НОРМАС
        Связный список    НОРМАС       НОРМАС     ОХРЕНЕННО    ОХРЕНЕННО
Двоичное дерево поиска    КРУТО        КРУТО      КРУТО        КРУТО
```

**Список** — представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз.
```
Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними.
Но для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти.
```
Сложность операции доступа в список — O(1)  
Удаление элемента из конца списка — O(1)  
Добавление элемента в начало списка — линейно O(N)  
Удаление элемента из начала списка — линейно O(N)  

**Хеш-таблица** — неупорядоченная структура данных. Вместо индексов мы работаем с «ключами» и «значениями», вычисляя адрес памяти по ключу.

Сложность чтения значения из хеш-таблицы — константа O(1)  
Сложность установки значения в хеш-таблицу — константа O(1)  
Сложность удаления значения из хеш-таблицы — константа O(1)  

**Стеки** похожи на списки. Они также упорядочены, но ограничены в действиях: можно лишь добавлять и убирать значения из конца списка. 
















